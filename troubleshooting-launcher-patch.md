# 런처 트러블슈팅: 매니페스트 기반 패치 시스템 구축

## 1. 문제 상황: 비효율적인 게임 업데이트 프로세스

대용량 게임 클라이언트를 배포할 때 가장 큰 고민은 **"어떻게 효율적으로 업데이트를 제공할 것인가?"** 였습니다.

단순히 전체 게임 파일을 압축하여 제공하는 방식은 다음과 같은 명백한 문제점을 가집니다.

-   **불필요한 데이터 전송:** 작은 스크립트 파일 하나가 수정되어도, 사용자는 수십 GB에 달하는 전체 게임 클라이언트를 다시 다운로드해야 합니다.
-   **서버 트래픽 비용 증가:** 모든 사용자가 업데이트마다 전체 파일을 다운로드하면 막대한 서버 트래픽 비용이 발생합니다.
-   **잦은 업데이트에 대한 사용자 피로감:** 업데이트 시간이 길어질수록 사용자의 이탈률은 높아집니다.

이러한 문제를 해결하고 사용자에게 쾌적한 업데이트 경험을 제공하기 위해, **변경된 파일만 정확히 찾아내어 패치하는 시스템**을 직접 구축하기로 결정했습니다.

## 2. 해결 과정: 매니페스트(Manifest) 시스템 설계 및 구현

**매니페스트**는 "게임 클라이언트를 구성하는 모든 파일과 폴더의 목록과 각각의 고유 정보(해시값, 파일 크기 등)를 담고 있는 명세서"입니다. 이 매니페스트를 활용한 업데이트 프로세스는 다음과 같이 설계했습니다.

1.  **[배포 시] 매니페스트 생성:** 게임 개발자가 새 버전을 배포할 때, `manifestGenerator.js` 스크립트를 실행하여 모든 파일의 **MD5 해시값**과 파일 크기를 계산하고, 그 결과를 `manifest.json` 파일로 생성하여 게임 파일과 함께 AWS S3 서버에 업로드합니다.
2.  **[런처 실행 시] 매니페스트 비교:** 사용자가 런처를 실행하면, 런처는 가장 먼저 서버의 최신 `manifest.json`을 다운로드합니다.
3.  **[차이점 분석] 무결성 검사 및 패치 목록 생성:** 런처는 서버 매니페스트와 로컬에 설치된 게임 파일들을 비교합니다.
    -   로컬 파일이 없거나, 로컬 파일의 해시값이 서버와 다르면 '다운로드 목록'에 추가합니다.
    -   서버 매니페스트에는 없지만 로컬에는 존재하는 파일은 '삭제 목록'에 추가합니다.
4.  **[패치 실행] 최소한의 파일만 다운로드:** '다운로드 목록'에 있는 파일들만 AWS S3에서 다운로드하여 로컬 파일을 업데이트합니다.

### 핵심 구현: `manifestGenerator.js`

이 시스템의 핵심은 정확한 매니페스트를 생성하는 Node.js 스크립트였습니다. Node.js에 내장된 `crypto`와 `fs` 모듈을 활용하여 구현했습니다.

```javascript
// manifestGenerator.js의 일부
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

// 파일의 MD5 해시값을 계산하는 함수
function calculateFileHash(filePath) {
    const hash = crypto.createHash('md5');
    const fileData = fs.readFileSync(filePath);
    hash.update(fileData);
    return hash.digest('hex');
}

// 재귀적으로 디렉터리를 탐색하며 모든 파일의 정보를 수집하는 함수
function generateFileManifest(directory) {
    const manifest = { files: [] };

    // ... 재귀 탐색 로직 ...
    
    // 각 파일에 대해 해시값과 크기 계산
    const fileHash = calculateFileHash(fullPath);
    const fileSize = fs.statSync(fullPath).size;
    manifest.files.push({
        path: relativePath, // 프로젝트 루트 기준 상대 경로
        size: fileSize,
        hash: fileHash
    });

    // ...
    return manifest;
}
```
`fs.readdirSync`로 디렉터리를 재귀적으로 탐색하고, 각 파일의 내용을 읽어 `crypto.createHash('md5')`로 해시값을 생성하는 것이 핵심 로직입니다.

## 3. 결과 및 효과

-   **패치 용량 최소화:** 이제 사용자들은 변경된 파일만 다운로드하면 되므로, 업데이트 용량이 최대 GB 단위에서 수십 MB 단위로 획기적으로 감소했습니다.
-   **업데이트 시간 단축:** 다운로드 용량이 줄어듦에 따라 평균 업데이트 시간이 크게 단축되어 사용자 경험이 향상되었습니다.
-   **안정성 및 신뢰도 확보:** 파일 해시값을 통해 파일의 변조 여부까지 확인할 수 있는 무결성 검사 기능이 추가되어 패치의 신뢰도를 높였습니다.

이번 경험을 통해 대용량 파일을 다루는 데스크탑 애플리케이션의 배포 파이프라인을 깊이 이해하고, 운영 비용과 사용자 경험을 동시에 개선하는 문제 해결 능력을 기를 수 있었습니다.
